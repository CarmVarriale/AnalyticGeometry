classdef testFrame < matlab.unittest.TestCase

	properties

		world, fr1, fr2, fr3, fr4, fr5, fr6

	end

	methods (TestClassSetup)

		function addClassToPath(testCase)
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture(".."));
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture("../includes/TreeNode"));
		end

	end

	methods (TestMethodSetup)

		function createFrames(testCase)
			testCase.world = World.getWorld();

			testCase.fr1 = Frame("fr1", ...
				[0, 0, 0], [0, 0, 0], "321", testCase.world);
			testCase.fr2 = Frame("fr2", ...
				[0, 0, 0], [0, 0, 0], "321", testCase.world);
			testCase.fr3 = Frame("fr3", ...
				[3, 3, 3], [0, 0, 0], "321", testCase.world);
			testCase.fr4 = Frame("fr4", ...
				[0, 0, 0], [pi/2, 0, 0], "321", testCase.fr3);
			testCase.fr5 = Frame("fr5", ...
				[0, 0, 0], [0, pi/2, 0], "321", testCase.fr3);
			testCase.fr6 = Frame("fr6", ...
				[0, 0, 0], [0, 0, pi/2], "321", testCase.fr3);

			testCase.addTeardown(@clear, "World", "getWorld")
		end
	end

	methods (Test)

		function testCannotSetItselfAsReference(testCase)
			% Test that a frame cannot be set as its own reference
			try
				testCase.fr1.ref = testCase.fr1;
			catch ME
			end
			testCase.verifyMatches( ...
				ME.identifier, ...
				"TreeNode:set:parent");
			testCase.verifyMatches( ...
				ME.message, ...
				"Node cannot be its own parent");
		end


		function testCannotChangeWorldReference(testCase)
			% Test that a frame cannot change its world reference
			try
				testCase.world.ref = testCase.fr2;
			catch ME
			end
			testCase.verifyMatches( ...
				ME.identifier, ...
				"Frame:set:ref");
			testCase.verifyMatches( ...
				ME.message, ...
				"World cannot have a non-empty ref Frame");
		end


		function testChangeReferenceAfterCreation(testCase)
			% Test that a frame reference can be changed after creation
			testCase.verifyEqual(testCase.fr1.ref, testCase.world);
			testCase.verifyEqual(testCase.fr2.ref, testCase.world);
			testCase.verifyEqual(testCase.fr2.parent, testCase.world);
			testCase.fr2.ref = testCase.fr1;
			testCase.verifyEqual(testCase.fr2.ref, testCase.fr1);
			testCase.verifyEqual(testCase.fr2.parent, testCase.fr1);
			testCase.verifyEqual(testCase.fr1.ref, testCase.world);
			testCase.verifyEqual(testCase.fr1.parent, testCase.world);
			testCase.verifyEqual(testCase.fr1.children, testCase.fr2);
			testCase.verifyEqual( ...
				testCase.world.children, ...
				[testCase.fr1, testCase.fr3]');
		end


		function testCannotConstructFrameWithNullName(testCase)
			% Test that a frame cannot be constructed with a null name
			try
				Frame("", [0 0 0], [0 0 0], "321", testCase.world);
			catch ME
			end
			testCase.verifyMatches( ...
				ME.identifier, ...
				"MATLAB:validators:mustBeNonzeroLengthText");
			testCase.verifyMatches( ...
				ME.message, ...
				"Value must be text with one or more characters.");
		end


		function testCannotChangeName(testCase)
			% Test that a frame uID cannot be changed
			try
				testCase.fr1.uID = "newName";
			catch ME
			end
			testCase.verifyMatches(ME.identifier, "Frame:set:uID");
			testCase.verifyMatches( ...
				ME.message, ...
				"Frame uID cannot be changed after creation");
		end


		function testIsNameUnique(testCase)
			% Test that isNameUnique method works correctly
			try
				Frame("fr1", [0 0 0], [0 0 0], "321", testCase.world);
			catch ME
				testCase.verifyMatches( ...
					ME.identifier, ...
					"Frame:Frame");
				testCase.verifyMatches( ...
					ME.message, ...
					"uID is not unique in the Frame tree");
			end
		end


		function testBaseOrientation(testCase)
			testCase.verifyEqual( ...
				unique([testCase.fr4.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr4.triad(1).coords, ...
				[0; 1; 0]);
			testCase.verifyEqual( ...
				testCase.fr4.triad(2).coords, ...
				[-1; 0; 0]);
			testCase.verifyEqual( ...
				testCase.fr4.triad(3).coords, ...
				[0; 0; 1]);
			testCase.verifyEqual( ...
				testCase.fr4.orien.coords, ...
				[0, -1, 0; 1, 0, 0; 0, 0, 1]);

			testCase.verifyEqual( ...
				unique([testCase.fr5.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr5.triad(1).coords, ...
				[0; 0; -1]);
			testCase.verifyEqual( ...
				testCase.fr5.triad(2).coords, ...
				[0; 1; 0]);
			testCase.verifyEqual( ...
				testCase.fr5.triad(3).coords, ...
				[1; 0; 0]);
			testCase.verifyEqual( ...
				testCase.fr5.orien.coords, ...
				[0, 0, 1; 0, 1, 0; -1, 0, 0]);

			testCase.verifyEqual( ...
				unique([testCase.fr6.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr6.triad(1).coords, ...
				[1; 0; 0]);
			testCase.verifyEqual( ...
				testCase.fr6.triad(2).coords, ...
				[0; 0; 1]);
			testCase.verifyEqual( ...
				testCase.fr6.triad(3).coords, ...
				[0; -1; 0;]);
			testCase.verifyEqual( ...
				testCase.fr6.orien.coords, ...
				[1, 0, 0; 0, 0, -1; 0, 1, 0]);
		end


		function testTranslate(testCase)
			vec = Vector([1; 2; 3], testCase.fr1.ref);
			testCase.verifyEqual( ...
				testCase.fr1.translate(vec).origin.coords, ...
				[1;2;3]);
			testCase.verifyEqual( ...
				testCase.fr3.translate(vec).locat, ...
				[4;5;6]);
		end


		function testRotate(testCase)
			fr3rot = testCase.fr3.rotate( ...
				Orien([pi/2 0 0], "321", testCase.world), ...
				testCase.fr1.origin.resolveInWorld());

			testCase.verifyEqual(fr3rot.locat, [-3;3;3]);
			testCase.verifyEqual(fr3rot.angles, [pi/2; 0; 0]);
		end

	end
end