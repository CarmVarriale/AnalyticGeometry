classdef testFrame < matlab.unittest.TestCase

	properties

		world, fr1, fr2, fr3, fr4, fr5, fr6

	end

	methods (TestClassSetup)

		function addClassToPath(testCase)
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture(".."));
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture("../includes/TreeNode"));
		end

	end

	methods (TestMethodSetup)

		function createFrames(testCase)
			testCase.world = World.getWorld();

			testCase.fr1 = Frame("fr1", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			testCase.fr2 = Frame("fr2", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			testCase.fr3 = Frame("fr3", ...
				Point([3; 3; 3], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			testCase.fr4 = Frame("fr4", ...
				Point([0; 0; 0], testCase.fr3), ...
				Orien([pi/2; 0; 0], "321", testCase.fr3), ...
				testCase.fr3);
			testCase.fr5 = Frame("fr5", ...
				Point([0; 0; 0], testCase.fr3), ...
				Orien([0; pi/2; 0], "321", testCase.fr3), ...
				testCase.fr3);
			testCase.fr6 = Frame("fr6", ...
				Point([0; 0; 0], testCase.fr3), ...
				Orien([0; 0; pi/2], "321", testCase.fr3), ...
				testCase.fr3);

			testCase.addTeardown(@clear, "World", "getWorld")
		end
	end

	methods (Test)

		function testCannotSetItselfAsReference(testCase)
			% Test that a frame cannot be set as its own reference
			try
				testCase.fr1.ref = testCase.fr1;
			catch ME
				testCase.verifyMatches( ...
					ME.identifier, ...
					"TreeNode:set:parent");
				testCase.verifyMatches( ...
					ME.message, ...
					"Node cannot be its own parent");
			end
		end


		function testCannotChangeWorldReference(testCase)
			% Test that a frame cannot change its world reference
			try
				testCase.world.ref = testCase.fr2;
			catch ME
			end
			testCase.verifyMatches( ...
				ME.identifier, ...
				"Frame:set:ref");
			testCase.verifyMatches( ...
				ME.message, ...
				"World cannot have a non-empty ref Frame");
		end


		function testChangeReferenceAfterCreation(testCase)
			% Test that a frame reference can be changed after creation
			testCase.verifyEqual(testCase.fr1.ref, testCase.world);
			testCase.verifyEqual(testCase.fr2.ref, testCase.world);
			testCase.verifyEqual(testCase.fr2.parent, testCase.world);
			testCase.fr2.ref = testCase.fr1;
			testCase.verifyEqual(testCase.fr2.ref, testCase.fr1);
			testCase.verifyEqual(testCase.fr2.parent, testCase.fr1);
			testCase.verifyEqual(testCase.fr1.ref, testCase.world);
			testCase.verifyEqual(testCase.fr1.parent, testCase.world);
			testCase.verifyEqual(testCase.fr1.children, testCase.fr2);
			testCase.verifyEqual( ...
				testCase.world.children, ...
				[testCase.fr1, testCase.fr3]');
		end


		function testCannotConstructFrameWithNullName(testCase)
			% Test that a frame cannot be constructed with a null name
			try
				Frame("", ...
					Point([0; 0; 0], testCase.world), ...
					Orien([0; 0; 0], "321", testCase.world), ...
					testCase.world);
			catch ME
			end
			testCase.verifyMatches( ...
				ME.identifier, ...
				"MATLAB:validators:mustBeNonzeroLengthText");
			testCase.verifyMatches( ...
				ME.message, ...
				"Value must be text with one or more characters.");
		end


		function testIsNameUnique(testCase)
			% Test that isNameUnique method works correctly
			try
				Frame("fr1", ...
					Point([0; 0; 0], testCase.world), ...
					Orien([0; 0; 0], "321", testCase.world), ...
					testCase.world);
			catch ME
				testCase.verifyMatches( ...
					ME.identifier, ...
					"Frame:Frame");
				testCase.verifyMatches( ...
					ME.message, ...
					"uID is not unique in the Frame tree");
			end
		end


		function testBaseOrientation(testCase)
			testCase.verifyEqual( ...
				unique([testCase.fr4.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr4.triad(1).coords, ...
				[0; 1; 0]);
			testCase.verifyEqual( ...
				testCase.fr4.triad(2).coords, ...
				[-1; 0; 0]);
			testCase.verifyEqual( ...
				testCase.fr4.triad(3).coords, ...
				[0; 0; 1]);
			testCase.verifyEqual( ...
				testCase.fr4.orien.coords, ...
				[0, -1, 0; 1, 0, 0; 0, 0, 1]);

			testCase.verifyEqual( ...
				unique([testCase.fr5.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr5.triad(1).coords, ...
				[0; 0; -1]);
			testCase.verifyEqual( ...
				testCase.fr5.triad(2).coords, ...
				[0; 1; 0]);
			testCase.verifyEqual( ...
				testCase.fr5.triad(3).coords, ...
				[1; 0; 0]);
			testCase.verifyEqual( ...
				testCase.fr5.orien.coords, ...
				[0, 0, 1; 0, 1, 0; -1, 0, 0]);

			testCase.verifyEqual( ...
				unique([testCase.fr6.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr6.triad(1).coords, ...
				[1; 0; 0]);
			testCase.verifyEqual( ...
				testCase.fr6.triad(2).coords, ...
				[0; 0; 1]);
			testCase.verifyEqual( ...
				testCase.fr6.triad(3).coords, ...
				[0; -1; 0;]);
			testCase.verifyEqual( ...
				testCase.fr6.orien.coords, ...
				[1, 0, 0; 0, 0, -1; 0, 1, 0]);
		end


		function testDefaultObject(testCase)
			frDefault = Frame();
			testCase.verifyEqual(frDefault.uID, "Default Frame");
			testCase.verifyEqual(frDefault.origin.coords, [0;0;0]);
			testCase.verifyEqual(frDefault.orien.angles, [0;0;0]);
			testCase.verifyEqual(frDefault.orien.seqID, "321");
			testCase.verifyEqual(frDefault.ref, World.getWorld());

			frArrayDefault(5) = Frame( ...
				"TestArray", ...
				Point([1;2;3], testCase.world), ...
				Orien([pi/4; pi/4; pi/4], "321", testCase.world), ...
				testCase.world);
			testCase.verifyEqual(frArrayDefault(5).uID, "TestArray");
			testCase.verifyEqual(frArrayDefault(1).uID, "Default Frame");
			testCase.verifyEqual(frArrayDefault(2).uID, "Default Frame");
			testCase.verifyNotSameHandle( ...
				frArrayDefault(1), ...
				frArrayDefault(2));
		end


		function testTranslate(testCase)
			vec = Vector([1; 2; 3], testCase.fr1.ref);
			testCase.verifyEqual( ...
				testCase.fr1.translate(vec).origin.coords, ...
				[1;2;3]);
			testCase.verifyEqual( ...
				testCase.fr3.translate(vec).origin.coords, ...
				[4;5;6]);
			testCase.verifySameHandle( ...
				testCase.fr1.translate(vec), ...
				testCase.fr1);
			testCase.verifyNotSameHandle( ...
				testCase.fr3.translateNew(vec), ...
				testCase.fr3);
		end


		function testRotate(testCase)
			fr3rot = testCase.fr3.rotate( ...
				Orien([pi/2; 0; 0], "321", testCase.world), ...
				testCase.fr1.origin.resolveInWorld());

			testCase.verifyEqual(fr3rot.origin.coords, [-3;3;3]);
			testCase.verifyEqual(fr3rot.orien.angles, [pi/2; 0; 0]);
		end


		function testCopy(testCase)
			fr1copy = copy(testCase.fr1);

			testCase.verifyNotSameHandle(fr1copy, testCase.fr1);
			testCase.verifyEqual(fr1copy, testCase.fr1);
			testCase.verifyEqual(fr1copy.uID, testCase.fr1.uID);
			testCase.verifyEqual(fr1copy.origin, testCase.fr1.origin);
			testCase.verifyEqual(fr1copy.orien, testCase.fr1.orien);
			
			testCase.verifyEqual(fr1copy.ref, testCase.fr1.ref);
			testCase.verifySameHandle(fr1copy.ref, testCase.fr1.ref);
			testCase.verifyTrue(testCase.fr1.isChildOf(testCase.world));
			testCase.verifyTrue(fr1copy.isChildOf(testCase.world));
			testCase.verifyTrue(fr1copy.isChildOf(testCase.fr1.parent));
			testCase.verifyTrue(fr1copy.isChildOf(testCase.fr1.ref));
			testCase.verifyTrue(fr1copy.isSiblingOf(testCase.fr1));
		end

	end
	
end