classdef testFrame < matlab.unittest.TestCase

	properties

		world, fr1, fr2, fr3, fr4, fr5, fr6

	end

	methods (TestClassSetup)

		function addClassToPath(testCase)
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture(".."));
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture("../includes/TreeNode"));
		end

	end

	methods (TestMethodSetup)

		function createFrames(testCase)
			testCase.world = World.getWorld();

			testCase.fr1 = Frame("fr1", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			testCase.fr2 = Frame("fr2", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			testCase.fr3 = Frame("fr3", ...
				Point([3; 3; 3], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			testCase.fr4 = Frame("fr4", ...
				Point([0; 0; 0], testCase.fr3), ...
				Orien([pi/2; 0; 0], "321", testCase.fr3), ...
				testCase.fr3);
			testCase.fr5 = Frame("fr5", ...
				Point([0; 0; 0], testCase.fr3), ...
				Orien([0; pi/2; 0], "321", testCase.fr3), ...
				testCase.fr3);
			testCase.fr6 = Frame("fr6", ...
				Point([0; 0; 0], testCase.fr3), ...
				Orien([0; 0; pi/2], "321", testCase.fr3), ...
				testCase.fr3);

			testCase.addTeardown(@clear, "World", "getWorld")
		end
	end

	methods (Test)

		function testCannotSetItselfAsReference(testCase)
			% Test that a frame cannot be set as its own reference
			try
				testCase.fr1.ref = testCase.fr1;
			catch ME
				testCase.verifyMatches( ...
					ME.identifier, ...
					"TreeNode:set:parent");
				testCase.verifyMatches( ...
					ME.message, ...
					"Node cannot be its own parent");
			end
		end


		function testCannotChangeWorldReference(testCase)
			% Test that a frame cannot change its world reference
			try
				testCase.world.ref = testCase.fr2;
			catch ME
			end
			testCase.verifyMatches( ...
				ME.identifier, ...
				"Frame:set:ref");
			testCase.verifyMatches( ...
				ME.message, ...
				"World cannot have a non-empty ref Frame");
		end


		function testChangeReferenceAfterCreation(testCase)
			% Test that a frame reference can be changed after creation
			testCase.verifyEqual(testCase.fr1.ref, testCase.world);
			testCase.verifyEqual(testCase.fr2.ref, testCase.world);
			testCase.verifyEqual(testCase.fr2.parent, testCase.world);
			testCase.fr2.ref = testCase.fr1;
			testCase.verifyEqual(testCase.fr2.ref, testCase.fr1);
			testCase.verifyEqual(testCase.fr2.parent, testCase.fr1);
			testCase.verifyEqual(testCase.fr1.ref, testCase.world);
			testCase.verifyEqual(testCase.fr1.parent, testCase.world);
			testCase.verifyEqual(testCase.fr1.children, testCase.fr2);
			testCase.verifyEqual( ...
				testCase.world.children, ...
				[testCase.fr1, testCase.fr3]');
		end


		function testCannotConstructFrameWithNullName(testCase)
			% Test that a frame cannot be constructed with a null name
			try
				Frame("", ...
					Point([0; 0; 0], testCase.world), ...
					Orien([0; 0; 0], "321", testCase.world), ...
					testCase.world);
			catch ME
			end
			testCase.verifyMatches( ...
				ME.identifier, ...
				"MATLAB:validators:mustBeNonzeroLengthText");
			testCase.verifyMatches( ...
				ME.message, ...
				"Value must be text with one or more characters.");
		end


		function testIsNameUnique(testCase)
			% Test that isNameUnique method works correctly
			try
				Frame("fr1", ...
					Point([0; 0; 0], testCase.world), ...
					Orien([0; 0; 0], "321", testCase.world), ...
					testCase.world);
			catch ME
				testCase.verifyMatches( ...
					ME.identifier, ...
					"Frame:Frame");
				testCase.verifyMatches( ...
					ME.message, ...
					"uID is not unique in the Frame tree");
			end
		end


		function testBaseOrientation(testCase)
			testCase.verifyEqual( ...
				unique([testCase.fr4.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr4.triad(1).coords, ...
				[0; 1; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr4.triad(2).coords, ...
				[-1; 0; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr4.triad(3).coords, ...
				[0; 0; 1], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr4.orien.coords, ...
				[0, -1, 0; 1, 0, 0; 0, 0, 1], ...
				AbsTol = 1e-15);

			testCase.verifyEqual( ...
				unique([testCase.fr5.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr5.triad(1).coords, ...
				[0; 0; -1], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr5.triad(2).coords, ...
				[0; 1; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr5.triad(3).coords, ...
				[1; 0; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr5.orien.coords, ...
				[0, 0, 1; 0, 1, 0; -1, 0, 0], ...
				AbsTol = 1e-15);

			testCase.verifyEqual( ...
				unique([testCase.fr6.triad.ref]), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr6.triad(1).coords, ...
				[1; 0; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr6.triad(2).coords, ...
				[0; 0; 1], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr6.triad(3).coords, ...
				[0; -1; 0;], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				testCase.fr6.orien.coords, ...
				[1, 0, 0; 0, 0, -1; 0, 1, 0], ...
				AbsTol = 1e-15);
		end


		function testDefaultObject(testCase)
			frDefault = Frame();
			testCase.verifyEqual(frDefault.name, "Default Frame");
			testCase.verifyEqual(frDefault.origin.coords, [0;0;0]);
			testCase.verifyEqual(frDefault.orien.angles, [0;0;0]);
			testCase.verifyEqual(frDefault.orien.seqID, "321");
			testCase.verifyEqual(frDefault.ref, World.getWorld());

			frArrayDefault(5) = Frame( ...
				"TestArray", ...
				Point([1;2;3], testCase.world), ...
				Orien([pi/4; pi/4; pi/4], "321", testCase.world), ...
				testCase.world);
			testCase.verifyEqual(frArrayDefault(5).name, "TestArray");
			testCase.verifyEqual(frArrayDefault(1).name, "Default Frame");
			testCase.verifyEqual(frArrayDefault(2).name, "Default Frame");
			testCase.verifyNotSameHandle( ...
				frArrayDefault(1), ...
				frArrayDefault(2));
		end


		function testTranslate(testCase)
			vec = Vector([1; 2; 3], testCase.fr1.ref);
			testCase.verifyEqual( ...
				testCase.fr1.translate(vec).origin.coords, ...
				[1;2;3]);
			testCase.verifyEqual( ...
				testCase.fr3.translate(vec).origin.coords, ...
				[4;5;6]);
			testCase.verifySameHandle( ...
				testCase.fr1.translate(vec), ...
				testCase.fr1);
			testCase.verifyNotSameHandle( ...
				testCase.fr3.translateNew("newID", vec), ...
				testCase.fr3);
			testCase.verifyEqual( ...
				testCase.fr3.translateNew("newID2", vec).name, ...
				"newID2");
		end


		function testRotate(testCase)
			fr3rot = testCase.fr3.rotate( ...
				Orien([pi/2; 0; 0], "321", testCase.world), ...
				testCase.fr1.origin.resolveInWorld());

			testCase.verifyEqual(fr3rot.origin.coords, [-3;3;3]);
			testCase.verifyEqual( ...
				fr3rot.orien.angles, ...
				[pi/2; 0; 0], ...
				AbsTol = 1e-15);
		end


		function testCopy(testCase)
			fr1copy = copy(testCase.fr1);

			testCase.verifyNotSameHandle(fr1copy, testCase.fr1);
			testCase.verifyEqual(fr1copy.name, testCase.fr1.name);
			testCase.verifyEqual(fr1copy.origin, testCase.fr1.origin);
			testCase.verifyEqual(fr1copy.orien, testCase.fr1.orien);
			
			% After copy, the copied frame has World as parent and ref
			testCase.verifyTrue(fr1copy.isChildOf(testCase.world));
			testCase.verifySameHandle(fr1copy.ref, testCase.world);
			
			% Original frame still has its parent and ref
			testCase.verifyTrue(testCase.fr1.isChildOf(testCase.world));
			testCase.verifyEqual(testCase.fr1.ref, testCase.world);
		end


		function testCopyWithChildren(testCase)
			% Test that copying a frame deep-copies all its children
			% and updates their parent references correctly
			
			% Create a parent with two children
			parent = Frame("Parent", ...
				Point([1; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			child1 = Frame("Child1", ...
				Point([0; 1; 0], parent), ...
				Orien([0; 0; 0], "321", parent), ...
				parent);
			child2 = Frame("Child2", ...
				Point([0; 0; 1], parent), ...
				Orien([0; 0; 0], "321", parent), ...
				parent);
			
			% Verify parent has two children
			testCase.verifyEqual(numel(parent.children), 2);
			
			% Copy the parent
			parentCopy = copy(parent);
			
			% Verify the copy has the same number of children
			testCase.verifyEqual(numel(parentCopy.children), 2);
			
			% Verify children are different objects (deep copy)
			testCase.verifyNotSameHandle(parentCopy.children(1), child1);
			testCase.verifyNotSameHandle(parentCopy.children(2), child2);
			
			% Verify copied children point to copied parent
			testCase.verifySameHandle(parentCopy.children(1).parent, parentCopy);
			testCase.verifySameHandle(parentCopy.children(2).parent, parentCopy);
			
			% Verify original children still point to original parent
			testCase.verifySameHandle(child1.parent, parent);
			testCase.verifySameHandle(child2.parent, parent);
			
			% Verify children have same properties
			testCase.verifyEqual(parentCopy.children(1).name, child1.name);
			testCase.verifyEqual(parentCopy.children(2).name, child2.name);
		end


		function testCopyWithGrandchildren(testCase)
			% Test that copying recursively copies the entire subtree
			
			% Create a three-level hierarchy
			grandparent = Frame("Grandparent", ...
				Point([1; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			parent = Frame("Parent", ...
				Point([0; 1; 0], grandparent), ...
				Orien([0; 0; 0], "321", grandparent), ...
				grandparent);
			child = Frame("Child", ...
				Point([0; 0; 1], parent), ...
				Orien([0; 0; 0], "321", parent), ...
				parent);
			
			% Copy the grandparent
			gpCopy = copy(grandparent);
			
			% Verify the entire tree is copied
			testCase.verifyEqual(numel(gpCopy.children), 1);
			testCase.verifyEqual(numel(gpCopy.children(1).children), 1);
			
			% Verify grandchild is a different object
			testCase.verifyNotSameHandle( ...
				gpCopy.children(1).children(1), child);
			
			% Verify parent-child links throughout the tree
			testCase.verifySameHandle( ...
				gpCopy.children(1).parent, gpCopy);
			testCase.verifySameHandle( ...
				gpCopy.children(1).children(1).parent, gpCopy.children(1));
			
			% Verify original tree is unchanged
			testCase.verifySameHandle(parent.parent, grandparent);
			testCase.verifySameHandle(child.parent, parent);
			
			% Verify properties are preserved
			testCase.verifyEqual(gpCopy.children(1).name, "Parent");
			testCase.verifyEqual(gpCopy.children(1).children(1).name, "Child");
		end


		function testCopyIndependence(testCase)
			% Test that modifying the copy doesn't affect the original
			
			parent = Frame("Parent", ...
				Point([1; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);
			child = Frame("Child", ...
				Point([0; 1; 0], parent), ...
				Orien([0; 0; 0], "321", parent), ...
				parent);
			
			parentCopy = copy(parent);
			
			% Modify the copied child
			parentCopy.children(1).origin = Point([5; 5; 5], parentCopy);
			
			% Verify original is unchanged
			testCase.verifyNotEqual( ...
				child.origin.coords, [5; 5; 5]);
			testCase.verifyEqual( ...
				child.origin.coords, [0; 1; 0]);
			
			% Verify copy is changed
			testCase.verifyEqual( ...
				parentCopy.children(1).origin.coords, [5; 5; 5]);
		end

	end
	
end