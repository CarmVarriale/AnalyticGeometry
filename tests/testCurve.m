classdef testCurve < matlab.unittest.TestCase

	properties
		frameFixture
		squarePoints, offsetSquarePoints, spatialPoints
	end

	properties (Constant)

		squareCoords = {[0;0;0]; [1;0;0]; [1;1;0]; [0;1;0]}
		offsetSquareCoords = {[1;0;0]; [2;0;0]; [2;1;0]; [1;1;0]}
		spatialCoords = {[1;2;3]; [4;5;6]; [7;8;9]}

	end

	methods (TestClassSetup)

		function addClassToPath(testCase)
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture(".."));
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture("../includes/TreeNode"));
		end

		function setupFrames(testCase)
			testCase.frameFixture = testCase.applyFixture(...
				FrameHierarchyFixture());
		end

	end

	methods (TestMethodSetup)

		function setupCurvePoints(testCase)
			% Create point arrays for curve tests
			testCase.squarePoints = cellfun( ...
				@(c) Point(c, testCase.frameFixture.fr2a), ...
				testCase.squareCoords);
			testCase.offsetSquarePoints = cellfun( ...
				@(c) Point(c, testCase.frameFixture.fr2a), ...
				testCase.offsetSquareCoords);
			testCase.spatialPoints = cellfun( ...
				@(c) Point(c, testCase.frameFixture.fr2a), ...
				testCase.spatialCoords);
		end

	end

	%%
	methods (Test)

		function testCreateCurveInEmptyFrame(testCase)
			try
				Curve(Point(rand(3,1), testCase.frameFixture.world), Frame.empty());
			catch ME
				testCase.verifyMatches( ...
					ME.identifier, ...
					"MATLAB:validation:IncompatibleSize");
			end
		end


		function testCreateArrayOfCurves(testCase)
			numCurves = 5;
			curvesArray = Curve.empty(numCurves,0);
			for i = 1:numCurves
				curvesArray(i) = Curve( ...
					Point(rand(3,1), testCase.frameFixture.world), ...
					testCase.frameFixture.world);
			end
			testCase.verifyEqual(length(curvesArray), numCurves);

			curvesArrayDefault(5) = Curve( ...
				[
				Point(rand(3,1), testCase.frameFixture.world), ...
				Point(rand(3,1), testCase.frameFixture.world), ...
				Point(rand(3,1), testCase.frameFixture.world), ...
				], ...
				testCase.frameFixture.world);
			testCase.verifyEqual( ...
				curvesArrayDefault(1).points(1).coords, [0; 0; 0]);
			testCase.verifyEqual( ...
				curvesArrayDefault(1).points(1).ref.name, ...
				"World")
			testCase.verifyEqual( ...
				curvesArrayDefault(2).points(1).ref.name, ...
				"World")
		end


		function testViewInDifferentFrames(testCase)
			curve = Curve(testCase.squarePoints, testCase.frameFixture.fr2a);
			testCase.verifyEqual( ...
				curve.coords, ...
				testCase.squareCoords);
			testCase.verifyEqual( ...
				curve.resolveIn(testCase.frameFixture.fr2a).coords, ...
				testCase.squareCoords);

			coords = [testCase.squareCoords{:}]';
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.frameFixture.fr1).coords{:}]', ...
				coords + [2,0,0]);
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.frameFixture.world).coords{:}]', ...
				coords + [3,1,1]);
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.frameFixture.fr2b).coords{:}]', ...
				coords + [2,-2,0]);
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.frameFixture.fr3c).coords{:}]', ...
				[coords(:,2), -coords(:,1) - 2, coords(:,3) - 2], ...
				AbsTol = 1e-15);
		end


		function testTranslate(testCase)
			coords = [testCase.squareCoords{:}]';
			curve = Curve(testCase.squarePoints);
			displ = Vector([2; 3; 4], testCase.frameFixture.fr2a);

			testCase.verifyEqual( ...
				[curve.translate(displ).coords{:}]', ...
				coords + [2,3,4]);
			testCase.verifyEqual( ...
				[curve.translate(displ).coords{:}]', ...
				coords + [2,3,4]);
			testCase.verifyEqual(unique(curve.refs), testCase.frameFixture.fr2a);

			newCurve = curve.translate(displ);
			testCase.verifyEqual( ...
				[newCurve.coords{:}]', ...
				coords + [2,3,4]);
			testCase.verifyEqual( ...
				[newCurve.coords{:}]', ...
				[curve.coords{:}]' + [2,3,4]);
			testCase.verifyEqual(unique(newCurve.refs), testCase.frameFixture.fr2a);
		end


		function testRotate(testCase)
			coords = [testCase.offsetSquareCoords{:}]';
			curve = Curve(testCase.offsetSquarePoints, testCase.frameFixture.fr2a);
			p0 = Point([0; 0; 0], testCase.frameFixture.fr2a);
			
			orienX = Orien([0; 0; pi/2], "321", testCase.frameFixture.fr2a);
			testCase.verifyEqual( ...
				[curve.rotate(p0, orienX).coords{:}]', ...
				[1,0,0; 2,0,0; 2,0,1; 1,0,1], ...
				"AbsTol", 1e-15);

			orienY = Orien([0; pi/2; 0], "321", testCase.frameFixture.fr2a);
			testCase.verifyEqual( ...
				[curve.rotate(p0, orienY).coords{:}]', ...
				[0,0,-1; 0,0,-2; 0,1,-2; 0,1,-1], ...
				"AbsTol", 1e-10);
			testCase.verifyEqual(unique(curve.refs), testCase.frameFixture.fr2a);

			orienZ = Orien([pi/2; 0; 0], "321", testCase.frameFixture.fr2a);
			newCurveZ = curve.rotate(p0, orienZ);
			testCase.verifyEqual( ...
				[curve.coords{:}]', ...
				coords);
			testCase.verifyEqual( ...
				[newCurveZ.coords{:}]', ...
				[0,1,0; 0,2,0; -1,2,0; -1,1,0], ...
				"AbsTol", 1e-10);
			testCase.verifyEqual(unique(newCurveZ.refs), testCase.frameFixture.fr2a);
		end


		function testProject(testCase)
			coords = [testCase.spatialCoords{:}]';
			curve = Curve(testCase.spatialPoints, testCase.frameFixture.fr2a);

			testCase.verifyEqual( ...
				[curve.project("1").coords{:}]', ...
				[1,0,0; 4,0,0; 7,0,0]);
			testCase.verifyEqual( ...
				[curve.project("2").coords{:}]', ...
				[0,2,0; 0,5,0; 0,8,0]);
			testCase.verifyEqual( ...
				[curve.project("3").coords{:}]', ...
				[0,0,3; 0,0,6; 0,0,9]);
			testCase.verifyEqual( ...
				[curve.project("12").coords{:}]', ...
				[1,2,0; 4,5,0; 7,8,0]);
			testCase.verifyEqual( ...
				[curve.project("13").coords{:}]', ...
				[1,0,3; 4,0,6; 7,0,9]);
			testCase.verifyEqual( ...
				[curve.project("23").coords{:}]', ...
				[0,2,3; 0,5,6; 0,8,9]);

			newCurve = curve.project("12");
			testCase.verifyEqual( ...
				[curve.coords{:}]', ...
				coords);
			testCase.verifyEqual( ...
				[newCurve.coords{:}]', ...
				[1,2,0; 4,5,0; 7,8,0]);
			testCase.verifyEqual(unique(newCurve.refs), testCase.frameFixture.fr2a);
		end


		function testDisp(testCase)
			curve = Curve(testCase.spatialPoints, testCase.frameFixture.fr2a);
			testCase.verifyWarningFree(@() disp(curve));
			testCase.verifyWarningFree(@() disp(Curve.empty));
		end


		function testRotateCurveAroundLineWithAngle(testCase)
			% Test rotating curve around a line using axis-angle representation
			curve = Curve( ...
				testCase.offsetSquarePoints, ...
				testCase.frameFixture.fr2a);
			
			% Define rotation line (Z-axis through origin)
			p1 = Point([0; 0; 0], testCase.frameFixture.fr2a);
			p2 = Point([0; 0; 1], testCase.frameFixture.fr2a);
			lineZ = Line(p1, p2);
			
			% Rotate 90° around Z-axis
			rotatedCurve = curve.rotate(lineZ, pi/2);
			
			% Expected result: square rotated 90° CCW around Z
			testCase.verifyEqual( ...
				[rotatedCurve.coords{:}]', ...
				[0,1,0; 0,2,0; -1,2,0; -1,1,0], ...
				"AbsTol", 1e-10);
			testCase.verifyEqual( ...
				unique(rotatedCurve.refs), ...
				testCase.frameFixture.fr2a);
		end


		function testRotateCurveAroundLineWithOrientation(testCase)
			% Test that rotate works with Line+Orien (should use first arg as Point)
			curve = Curve( ...
				testCase.offsetSquarePoints, ...
				testCase.frameFixture.fr2a);
			
			% Define rotation line
			p1 = Point([0; 0; 0], testCase.frameFixture.fr2a);
			p2 = Point([0; 0; 1], testCase.frameFixture.fr2a);
			lineZ = Line(p1, p2);
			
			% Should interpret lineZ as Point (using anchor) with Orien
			orienZ = Orien([pi/2; 0; 0], "321", testCase.frameFixture.fr2a);
			rotatedCurve = curve.rotate(lineZ.anchor, orienZ);
			
			% Expected result: same as testRotate with orienZ
			testCase.verifyEqual( ...
				[rotatedCurve.coords{:}]', ...
				[0,1,0; 0,2,0; -1,2,0; -1,1,0], ...
				"AbsTol", 1e-10);
		end


		function testRotateCurveAroundDifferentAxes(testCase)
			% Test rotating around X and Y axes using Line representation
			curve = Curve( ...
				testCase.offsetSquarePoints, ...
				testCase.frameFixture.fr2a);
			
			% X-axis line
			lineX = Line( ...
				Point([0; 0; 0], testCase.frameFixture.fr2a), ...
				Point([1; 0; 0], testCase.frameFixture.fr2a));
			
			% Rotate 90° around X-axis
			rotatedX = curve.rotate(lineX, pi/2);
			testCase.verifyEqual( ...
				[rotatedX.coords{:}]', ...
				[1,0,0; 2,0,0; 2,0,1; 1,0,1], ...
				"AbsTol", 1e-10);
			
			% Y-axis line
			lineY = Line( ...
				Point([0; 0; 0], testCase.frameFixture.fr2a), ...
				Point([0; 1; 0], testCase.frameFixture.fr2a));
			
			% Rotate 90° around Y-axis
			rotatedY = curve.rotate(lineY, pi/2);
			testCase.verifyEqual( ...
				[rotatedY.coords{:}]', ...
				[0,0,-1; 0,0,-2; 0,1,-2; 0,1,-1], ...
				"AbsTol", 1e-10);
		end


		function testRotateCurveAroundOffsetLine(testCase)
			% Test rotating around a line that doesn't pass through origin
			curve = Curve( ...
				testCase.offsetSquarePoints, ...
				testCase.frameFixture.fr2a);
			
			% Line parallel to Z-axis but offset in X
			offsetLine = Line( ...
				Point([1; 0; 0], testCase.frameFixture.fr2a), ...
				Point([1; 0; 1], testCase.frameFixture.fr2a));
			
			% Rotate 180° around offset line
			rotatedCurve = curve.rotate(offsetLine, pi);
			
			% Points should be mirrored across the line at x=1
			% [1,0,0] stays at [1,0,0]
			% [2,0,0] -> [0,0,0]
			% [2,1,0] -> [0,-1,0]
			% [1,1,0] -> [1,-1,0]
			testCase.verifyEqual( ...
				[rotatedCurve.coords{:}]', ...
				[1,0,0; 0,0,0; 0,-1,0; 1,-1,0], ...
				"AbsTol", 1e-10);
		end

	end

end