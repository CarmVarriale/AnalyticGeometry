classdef testCurve < matlab.unittest.TestCase

	properties

		world, fr1, fr2, fr2a, fr2b, fr2c, fr3a, fr3b, fr3c, ...
			squarePoints, offsetSquarePoints, spatialPoints

	end

	properties (Constant)

		squareCoords = {[0;0;0]; [1;0;0]; [1;1;0]; [0;1;0]}
		offsetSquareCoords = {[1;0;0]; [2;0;0]; [2;1;0]; [1;1;0]}
		spatialCoords = {[1;2;3]; [4;5;6]; [7;8;9]}

	end

	methods (TestClassSetup)

		function addClassToPath(testCase)
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture(".."));
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture("../includes/TreeNode"));
		end

	end

	methods (TestMethodSetup)

		function createTreeFrame(testCase)
			% Create tree of Frames with World at its root
			% The tree has the folllowing structure:
			%
			% World
			% ├── Frame1
			%     ├── Frame2a
			%     │   └── Frame3a
			%     ├── Frame2b
			%     │   └── Frame3b
			%     └── Frame2c
			%         └── Frame3c

			testCase.world = World.getWorld();

			testCase.fr1 = Frame("Frame1", ...
				Point([1; 1; 1], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);

			testCase.fr2a = Frame("Frame2a", ...
				Point([2; 0; 0], testCase.fr1), ...
				Orien([0; 0; 0], "321", testCase.fr1), ...
				testCase.fr1);
			testCase.fr2b = Frame("Frame2b", ...
				Point([0; 2; 0], testCase.fr1), ...
				Orien([0; 0; 0], "321", testCase.fr1), ...
				testCase.fr1);
			testCase.fr2c = Frame("Frame2c", ...
				Point([0; 0; 2], testCase.fr1), ...
				Orien([0; 0; 0], "321", testCase.fr1), ...
				testCase.fr1);

			testCase.fr3a = Frame("Frame3a", ...
				Point([0; 0; 0], testCase.fr2a), ...
				Orien([0; 0; pi/2], "321", testCase.fr2a), ...
				testCase.fr2a);
			testCase.fr3b = Frame("Frame3b", ...
				Point([0; 0; 0], testCase.fr2b), ...
				Orien([0; pi/2; 0], "321", testCase.fr2b), ...
				testCase.fr2b);
			testCase.fr3c = Frame("Frame3c", ...
				Point([0; 0; 0], testCase.fr2c), ...
				Orien([pi/2; 0; 0], "321", testCase.fr2c), ...
				testCase.fr2c);

			testCase.squarePoints = cellfun( ...
				@(c) Point(c, testCase.fr2a), ...
				testCase.squareCoords);
			testCase.offsetSquarePoints = cellfun( ...
				@(c) Point(c, testCase.fr2a), ...
				testCase.offsetSquareCoords);
			testCase.spatialPoints = cellfun( ...
				@(c) Point(c, testCase.fr2a), ...
				testCase.spatialCoords);

			testCase.addTeardown(@clear, "World", "getWorld")
		end

	end

	%%
	methods (Test)

		function testCreateCurveInEmptyFrame(testCase)
			try
				Curve(Point(rand(3,1), testCase.world), Frame.empty());
			catch ME
				testCase.verifyMatches( ...
					ME.identifier, ...
					"MATLAB:validation:IncompatibleSize");
			end
		end


		function testCreateArrayOfCurves(testCase)
			numCurves = 5;
			curvesArray = Curve.empty(numCurves,0);
			for i = 1:numCurves
				curvesArray(i) = Curve( ...
					Point(rand(3,1), testCase.world), ...
					testCase.world);
			end
			testCase.verifyEqual(length(curvesArray), numCurves);

			curvesArrayDefault(5) = Curve( ...
				[
				Point(rand(3,1), testCase.world), ...
				Point(rand(3,1), testCase.world), ...
				Point(rand(3,1), testCase.world), ...
				], ...
				testCase.world);
			testCase.verifyEqual( ...
				curvesArrayDefault(1).points(1).coords, [0; 0; 0]);
			testCase.verifyEqual( ...
				curvesArrayDefault(1).points(1).ref.name, ...
				"World")
			testCase.verifyEqual( ...
				curvesArrayDefault(2).points(1).ref.name, ...
				"World")
		end


		function testViewInDifferentFrames(testCase)
			curve = Curve(testCase.squarePoints, testCase.fr2a);
			testCase.verifyEqual( ...
				curve.coords, ...
				testCase.squareCoords);
			testCase.verifyEqual( ...
				curve.resolveIn(testCase.fr2a).coords, ...
				testCase.squareCoords);

			coords = [testCase.squareCoords{:}]';
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.fr1).coords{:}]', ...
				coords + [2,0,0]);
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.world).coords{:}]', ...
				coords + [3,1,1]);
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.fr2b).coords{:}]', ...
				coords + [2,-2,0]);
			testCase.verifyEqual( ...
				[curve.resolveIn(testCase.fr3c).coords{:}]', ...
				[coords(:,2), -coords(:,1) - 2, coords(:,3) - 2]);
		end


		function testTranslate(testCase)
			coords = [testCase.squareCoords{:}]';
			curve = Curve(testCase.squarePoints);
			displ = Vector([2; 3; 4], testCase.fr2a);

			testCase.verifyEqual( ...
				[curve.translate(displ).coords{:}]', ...
				coords + [2,3,4]);
			testCase.verifyEqual( ...
				[curve.translate(displ).coords{:}]', ...
				coords + [2,3,4]);
			testCase.verifyEqual(unique(curve.refs), testCase.fr2a);

			newCurve = curve.translate(displ);
			testCase.verifyEqual( ...
				[newCurve.coords{:}]', ...
				coords + [2,3,4]);
			testCase.verifyEqual( ...
				[newCurve.coords{:}]', ...
				[curve.coords{:}]' + [2,3,4]);
			testCase.verifyEqual(unique(newCurve.refs), testCase.fr2a);
		end


		function testRotate(testCase)
			coords = [testCase.offsetSquareCoords{:}]';
			curve = Curve(testCase.offsetSquarePoints, testCase.fr2a);
			p0 = Point([0; 0; 0], testCase.fr2a);
			
			orienX = Orien([0; 0; pi/2], "321", testCase.fr2a);
			testCase.verifyEqual( ...
				[curve.rotate(orienX, p0).coords{:}]', ...
				[1,0,0; 2,0,0; 2,0,1; 1,0,1], ...
				"AbsTol", 1e-15);

			orienY = Orien([0; pi/2; 0], "321", testCase.fr2a);
			testCase.verifyEqual( ...
				[curve.rotate(orienY, p0).coords{:}]', ...
				[0,0,-1; 0,0,-2; 0,1,-2; 0,1,-1], ...
				"AbsTol", 1e-10);
			testCase.verifyEqual(unique(curve.refs), testCase.fr2a);

			orienZ = Orien([pi/2; 0; 0], "321", testCase.fr2a);
			newCurveZ = curve.rotate(orienZ, p0);
			testCase.verifyEqual( ...
				[curve.coords{:}]', ...
				coords);
			testCase.verifyEqual( ...
				[newCurveZ.coords{:}]', ...
				[0,1,0; 0,2,0; -1,2,0; -1,1,0], ...
				"AbsTol", 1e-10);
			testCase.verifyEqual(unique(newCurveZ.refs), testCase.fr2a);
		end


		function testProject(testCase)
			coords = [testCase.spatialCoords{:}]';
			curve = Curve(testCase.spatialPoints, testCase.fr2a);

			testCase.verifyEqual( ...
				[curve.project("1").coords{:}]', ...
				[1,0,0; 4,0,0; 7,0,0]);
			testCase.verifyEqual( ...
				[curve.project("2").coords{:}]', ...
				[0,2,0; 0,5,0; 0,8,0]);
			testCase.verifyEqual( ...
				[curve.project("3").coords{:}]', ...
				[0,0,3; 0,0,6; 0,0,9]);
			testCase.verifyEqual( ...
				[curve.project("12").coords{:}]', ...
				[1,2,0; 4,5,0; 7,8,0]);
			testCase.verifyEqual( ...
				[curve.project("13").coords{:}]', ...
				[1,0,3; 4,0,6; 7,0,9]);
			testCase.verifyEqual( ...
				[curve.project("23").coords{:}]', ...
				[0,2,3; 0,5,6; 0,8,9]);

			newCurve = curve.project("12");
			testCase.verifyEqual( ...
				[curve.coords{:}]', ...
				coords);
			testCase.verifyEqual( ...
				[newCurve.coords{:}]', ...
				[1,2,0; 4,5,0; 7,8,0]);
			testCase.verifyEqual(unique(newCurve.refs), testCase.fr2a);
		end


		function testDisp(testCase)
			curve = Curve(testCase.spatialPoints, testCase.fr2a);
			testCase.verifyWarningFree(@() disp(curve));
			testCase.verifyWarningFree(@() disp(Curve.empty));
		end

	end

end