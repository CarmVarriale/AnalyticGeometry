classdef testTensor < matlab.unittest.TestCase

	properties

		world, fr0, fr1, fr2, fr3, I0, Irot1, Irot2, Irot3
	
	end

	methods (TestClassSetup)

		function addClassToPath(testCase)
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture(".."));
			testCase.applyFixture( ...
				matlab.unittest.fixtures.PathFixture("../includes/TreeNode"));
		end
		
	end
	
	methods (TestMethodSetup)

		function createObjects(testCase)

			testCase.world = World.getWorld();

			testCase.fr0 = Frame("Frame0", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([0; 0; 0], "321", testCase.world), ...
				testCase.world);

			testCase.fr1 = Frame("Frame1", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([atan(-0.5); 0; 0], "321", testCase.world), ...
				testCase.world);

			testCase.fr2 = Frame("Frame2", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([pi/2 + atan(-0.5); 0; 0], "321", testCase.world), ...
				testCase.world);

			testCase.fr3 = Frame("Frame3", ...
				Point([0; 0; 0], testCase.world), ...
				Orien([pi/2; pi; pi/2], "321", testCase.world), ...
				testCase.world);

			% Inertia tensor of right triangle with base=2, height=1, mass=1 
			% with respect to its vertex, in a frame with origin at the 
			% triangle vertex, X axis along the base, Y axis along the height
			testCase.I0 = Tensor( ... 
				[1/6, -1/6, 0; -1/6, 2/3, 0; 0, 0, 5/6], ...
				testCase.fr0);

			% Inertia tensor of right triangle with base=2, height=1, mass=1
			% with respect to its vertex, in a frame with origin at the 
			% triangle vertex, X axis parallel to the hypotenuse, Y axis
			% pointing in the first quadrant
			testCase.Irot1 = Tensor( ... 
				[2/5, -3/10, 0; -3/10 13/30, 0; 0, 0, 5/6], ...
				testCase.fr1);

			% Inertia tensor of right triangle with base=2, height=1, mass=1
			% with respect to its vertex, in a frame with origin at the 
			% triangle vertex, X axis perpendicular to the hypotenuse and 
			% pointing in the first quadrant
			testCase.Irot2 = Tensor( ... 
				[13/30, 3/10, 0; 3/10, 2/5, 0; 0, 0, 5/6], ...
				testCase.fr2);
			
			% Inertia tensor of right triangle with base=2, height=1, mass=1
			% with respect to its vertex, in a frame with origin at the 
			% triangle vertex, Z axis along the base, and X axis along the
			% height but opposite to it
			testCase.Irot3 = Tensor( ... 
				[2/3, 0 1/6; 0 5/6 0; 1/6 0 1/6], ...
				testCase.fr3);

			testCase.addTeardown(@clear, "World", "getWorld")
		end

	end

	%%
	methods (Test)

		function testCreateArrayOfTensors(testCase)
			numTensors = 5;
			tensorsArray = Tensor.empty(numTensors,0);
			for i = 1:numTensors
				tensorsArray(i) = Tensor(rand(3,3), testCase.world);
			end
			testCase.verifyEqual(length(tensorsArray), numTensors);

			tensorsArrayDefault(5) = Tensor(rand(3,3), testCase.world);
			testCase.verifyEqual(tensorsArrayDefault(1).coords, zeros(3,3))
			testCase.verifyEqual( ...
				tensorsArrayDefault(1).ref.name, ...
				"World")
			testCase.verifyEqual( ...
				tensorsArrayDefault(2).ref.name, ...
				"World")
		end


		function testViewIn(testCase)
			testCase.verifyEqual( ...
				testCase.I0.resolveIn(testCase.world).coords, ...
				testCase.I0.coords);
			testCase.verifyEqual( ...
				testCase.Irot1.resolveIn(testCase.world).coords, ...
				testCase.I0.coords, ...
				AbsTol=1e-12);
			testCase.verifyEqual( ...
				testCase.Irot2.resolveIn(testCase.world).coords, ...
				testCase.I0.coords, ...
				AbsTol=1e-12);

			testCase.verifyEqual( ...
				testCase.I0.resolveIn(testCase.fr1).coords, ...
				testCase.Irot1.coords, ...
				AbsTol=1e-12);
			testCase.verifyEqual( ...
				testCase.I0.resolveIn(testCase.fr2).coords, ...
				testCase.Irot2.coords, ...
				AbsTol=1e-12);

			testCase.verifyEqual( ...
				testCase.Irot1.resolveIn(testCase.fr2).coords, ...
				testCase.Irot2.coords, ...
				AbsTol=1e-12);

			testCase.verifyEqual( ...
				testCase.I0.resolveIn(testCase.fr3).coords, ...
				testCase.Irot3.coords, ...
				AbsTol=1e-12);
		end


		function testRotate(testCase)
			o = Orien([0; 0; 0], "321", testCase.fr0);
			testCase.verifyEqual( ...
				o.rotate(Orien([pi/2; 0; 0], "321", testCase.fr0)).angles, ...
				[pi/2; 0; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				o.rotate(Orien([-pi/2; 0; 0], "321", testCase.fr0)).angles, ...
				[-pi/2; 0; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				o.rotate(Orien([0; pi; 0], "321", testCase.fr0)).angles, ...
				[pi; 0; pi], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				o.rotate(Orien([0; -pi; 0], "321", testCase.fr0)).angles, ...
				[pi; 0; pi], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				o.rotate(Orien([0; 0; -pi/2], "321", testCase.fr0)).angles, ...
				[0; 0; -pi/2], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				o.rotate(Orien([pi/2; pi/2; pi/2], "321", testCase.fr0)).angles, ...
				[0; pi/2; 0], ...
				AbsTol = 1e-15);
			testCase.verifyEqual( ...
				o.rotate(Orien([pi/2; pi/2; 0], "321", testCase.fr0)).angles, ...
				[pi/2; pi/2; 0], ...
				AbsTol = 1e-15);
		end

	end

end
